# C++基础知识

## 常见关键字

### const

**作用**

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

**const 的指针与引用**

- 指针
  - 指向常量的指针（pointer to const）【`const int *p`;和`int const *p;` 二者等价】特点：const在*前面
  - 自身是常量的指针（常量指针，const pointer）【`int * const p;`】特点：const在*后面
- 引用
  - 指向常量的引用（reference to const）```const int & b = a;  *// 等价于int const & b = a;* ```
  - 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰

**术语：**顶层const：表示指针本身是个常量；底层const：表示所指的对象是个常量。

### this指针

1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，此时this的类型是非常量版本的常量指针，这意味着不能给 `this` 指针赋值，也意味着把this绑定到一个常量的对象上，这使得不能在常量对象上调用普通的成员函数；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）。这样将成员函数声明为const的做法，也有助于提高函数的灵活性。
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。

### define和typedef

typedef 定义类型的别名，编译阶段有效，有类型检查的功能；有作用域限制

```c++
typedef int* tp;
const tp ptr;    // 此时 ptr 为指针常量，使用 define 则为指向常量的指针
tp ptr1, ptr2;   // 二者都为指针，使用 define 则不是
```

define 是宏定义，发生在预处理阶段，只进行文本替换，不进行任何检查；没有作用域限制

### inline

在泪中，常有一些规模较小的函数适合被声明为内联函数，定义在泪内部的成员函数是自动inline。(P244)

定义在类内部的成员函数是自动内联的。

### 构造函数初始值

要善于使用构造函数初始化列表进行初始化，而不是在构造函数中进行赋值。原因有2:

1. 效率问题，如果是赋值进行构造函数的初始化的话，是先初始化，后赋值；相比初始化列表多了一个赋值操作。
2. const成员和引用成员必须使用初始化列表的方式进行。

### 委托构造函数

使用它所属其他构造函数执行他自己的初始化过程。

### explicit

在构造函数前面加explicit阻止类型的隐式转换。explicit只对一个实参的构造函数有效。此外exilicit关键字只能在类内声明构造函数时使用。(P297)

### 类的静态成员（static关键字）

静态成员只与类有关系，和对象无关。（p301）

因为静态数据乘员不属于类的任何一个对象，所以衙门并不是在创建类的对象时被定义的。这意味着他们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

## 指针与引用

1. 指针本身是一个对象，可以进行赋值和拷贝，在生命周期中可以指向多个对象；而引用并非一个对象，只能是一个已经存在的对象的别名，无法令其重新绑定到另一个对象，所以必须进行初始化。
2. 引用不是对象，没有实际地址，所以不能定义指向引用的指针。
3. 可以有自身const指针，但是没有自身是const引用。
4. 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
5. 指针的值可以为空，但是引用的值不能为NULL；
6. 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
7. "sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；
8. 指针和引用的自增(++)运算意义不一样，指针是对地址的自增，引用是对值的自增；
9. 其它：[引用的底层实现](https://blog.csdn.net/lws123253/article/details/80353197)。

